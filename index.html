<html>
<script src='https://d3js.org/d3.v5.min.js'></script>
<head>
    <title>Data Vis Project</title>
    <style>
        header h1 {
            text-align: center;
        }
        #master-container {
            display: flex;
        }
        #controls-container {
            flex: 1;
            max-width: 240;
        }
        #navigation-container {
            display: flex;
            justify-content: center;
        }
        button {
            width: 150px;
            height: 50px;
            margin: 10px;
            font-size: x-large;
            text-align: center;
        }
    </style>
</head>
<header>
    <h1>Data Project</h1>
</header>
<body onload='init()'>
    <div id='master-container'>
        <div id='graphic-container'>
            <svg></svg>
            <div id='navigation-container'>
                <button id='prevBtn'>Previous</button>
                <button id='nextBtn'>Next</button>
            </div>
        </div>
        <div id='controls-container'></div>
    </div>
     
    <script>
        let data1v1;
        async function init() {
            const r = await d3.csv('AoE2_ranked_1v1_data.csv', function(d) {
                d.avg_rating = Math.round((+d['rating.lose'] + +d['rating.win']) / 2);
                d.duration_min = +((+d.duration[d.duration.length - 2]) >= 3) + +d.duration.slice(-5, -3) + (60 * +d.duration.slice(0, -6));
                d.duration_min += (d.duration_min == 0); // have to alter this data a little in order to have valid domain for logarithmic scale.
                // 0 min matches are in practice the same as 1 min matches at least
                d.colorname_win = [null, '1. Blue', '2. Red', '3. Green', '4. Yellow', '5. Cyan', '6. Purple', '7. Grey', '8. Orange'][+d['color.win']];
                d.colorname_lose = [null, '1. Blue', '2. Red', '3. Green', '4. Yellow', '5. Cyan', '6. Purple', '7. Grey', '8. Orange'][+d['color.lose']];
                d['rating_change.win'] = +d['rating_change.win'];
                return d;
            });
            data1v1 = r;
            const prevBtn = document.getElementById('prevBtn');
            prevBtn.addEventListener('click', prevPage);
            const nextBtn = document.getElementById('nextBtn');
            nextBtn.addEventListener('click', nextPage);
            setPage(currPage);
            addDoubleSlider('Mean Rating: ', 'avg_rating', 'linear');
            addDoubleSlider('Duration (min):', 'duration_min', 'log');
        }
        function getData1v1() {
            return new Promise((resolve) => {
                const checkDataPresent = () => {
                    if (typeof data1v1 !== 'undefined' && data1v1 !== null) {
                        resolve(data1v1);
                    } else {
                        setTimeout(checkDataPresent, 100);
                    }
                }
                checkDataPresent();
            });
        }
        
        const margin = 50;
        const width = window.screen.width * 19 / 24;
        const height = window.screen.height * 3 / 5;
        const disp = d3.select('#graphic-container').select('svg')
                            .attr('width', width+2*margin).attr('height', height+2*margin);
        const controls = d3.select('#controls-container');

        function resetSVG() { disp.selectAll('*').remove(); }
        function newGroup(tx, ty) {
            return disp.append('g').attr('transform', 'translate(' + tx + ',' + ty + ')');
        }
        function colValCnts(data, colNames) {
            let cntMap = new Map();
            const entries = colNames.map(key => [key, 0]);
            data.forEach(row => {
                for (let colName of colNames) {
                    const val = row[colName];
                    if (val == null) continue;
                    cntMap.set(val, (cntMap.get(val) || Object.fromEntries(entries)));
                    cntMap.get(val)[colName] += filterOut(row);
                }
            });
            cntMap = sortMap(cntMap);
            return Array.from(cntMap, ([key, values]) => ({ category : key, ...values }));
        }
        const filters = {};
        function filterOut(row) {
            for (const [key, value] of Object.entries(filters)) {
                const val = cast(row[key], typeof(value[0]));
                if (!((val >= value[0]) && (val <= value[1]))) {
                    return false;
                }
            }
            return true;
        }
        function barGraph(data, colors) {
            let keys = Object.keys(data[0]);
            const category = keys[0];
            keys = keys.slice(1);
            const stack = d3.stack().keys(keys);
            const series = stack(data);
            const xs = d3.scaleBand().domain(data.map(d => d[category])).range([margin, width+margin]).padding(0.05);
            const ys = d3.scaleLinear().domain([0, d3.max(series[series.length - 1], d => d[1])]).range([height, 0]);
            const layers = disp.selectAll('.layer')
                                .data(series)
                                .join('g')
                                .attr('class', 'layer')
                                .attr('fill', (d, i) => colors[i]);
            layers.selectAll('.rect')
                .data(d => d).join('rect')
                .attr('x', d => xs(d.data[category]))
                .attr('y', d => ys(d[1]))
                .attr('width', xs.bandwidth())
                .attr('height', d => ys(d[0]) - ys(d[1]));
            // axes
            newGroup(0, height).call(d3.axisBottom(xs))
                .selectAll('text')
                    .style('font-size', '16px')
                    .style('text-anchor', 'end').attr('dx', '-.4em').attr('dy', '.2em').attr('transform', 'rotate(-50)');
            newGroup(margin, 0).call(d3.axisLeft(ys))
                .selectAll('text')
                    .style('font-size', '12px');
        }

        let currPage = 0;
        const totalPages = 4;
        async function setPage(pageNum) {
            const data = await getData1v1();
            resetSVG();
            switch (pageNum) {
            case 0:
                barGraph(colValCnts(data, ['map_type.name']), ['darkgrey']);
                break;
            case 1:
                barGraph(colValCnts(data, ['civ.win.name', 'civ.lose.name']), ['lightgreen', '#FF9998']);
                break;
            case 2:
                barGraph(colValCnts(data, ['colorname_win', 'colorname_lose']), ['lightgreen', '#FF9998']);
                break;
            case 3:
                barGraph(colValCnts(data, ['rating_change.win']), ['darkgrey']);
                break;
            default:
                break;
            }
        }

        async function prevPage() { await setPage(currPage = Math.max(currPage - 1, 0)); }
        async function nextPage() { await setPage(currPage = Math.min(currPage + 1, totalPages - 1)); }
        
        async function colRange(colName) {
            const data = await getData1v1();
            const range = [
                d3.min(data, function(d) { return +d[colName]; }),
                d3.max(data, function(d) { return +d[colName]; })
            ]
            return range;
        }

        async function addDoubleSlider(sldrName, colName, scaleType) {
            const cntrl_width = 240;
            const sldr_height = 50;
            const padding = 20;
            const sldr = controls.append('svg').attr('width', cntrl_width).attr('height', sldr_height);
            sldr.append('text').attr('x', 0).attr('y', sldr_height / 2).style('alignment-baseline', 'middle').text(sldrName);
            const range = await colRange(colName);
            const currRange = [...range];
            filters[colName] = currRange;
            let xs;
            switch (scaleType) {
            case 'log': xs = d3.scaleLog(); break;
            default: xs = d3.scaleLinear(); break;
            }
            xs = xs.domain(range).range([6 * sldrName.length + padding, cntrl_width - padding]);
            sldr.append('line')
                .attr('x1', xs.range()[0]).attr('y1', sldr_height / 2)
                .attr('x2', xs.range()[1]).attr('y2', sldr_height / 2)
                .attr('stroke', 'gray')
                .attr('stroke-width', 5);
            
            const handle1 = sldr.append('g')
                .attr('transform', 'translate(' + xs(range[0]) + ',' + (sldr_height / 2) + ')')
                .call(d3.drag().on('drag', () => { brush(d3.event.x, 0); }));
            handle1.append('circle').attr('r', 8).attr('fill', 'blue');
            const lbl1 = handle1.append('text').attr('y', 5 * sldr_height / 12).attr('x', 0)
                                .attr('text-anchor', 'middle').style('alignment-baseline', 'middle').text(range[0].toString());
            const handle2 = sldr.append('g')
                .attr('transform', 'translate(' + xs(range[1]) + ',' + (sldr_height / 2) + ')')
                .call(d3.drag().on('drag', () => { brush(d3.event.x, 1); }));
            handle2.append('circle').attr('r', 8).attr('fill', 'blue');
            const lbl2 = handle2.append('text').attr('y', -4 * sldr_height / 12).attr('x', 0)
                                .attr('text-anchor', 'middle').style('alignment-baseline', 'middle').text(range[1].toString());
            function brush(x, ind) {
                const newX = Math.max(xs.range()[0], Math.min(xs.range()[1], x));
                currRange[ind] = Math.max(range[0], Math.min(range[1], Math.round(xs.invert(newX))));
                if (currRange[0] > currRange[1]) {
                    currRange[ind] = currRange[1 - ind];
                }
                [handle1, handle2][ind].attr('transform', 'translate(' + xs(currRange[ind]) + ',' + (sldr_height / 2) + ')');
                [lbl1, lbl2][ind].text(currRange[ind]);
                setPage(currPage);
            }
        }

        function cast(val, type) {
            switch (type) {
            case 'boolean': return Boolean(val);
            case 'number': return Number(val);
            case 'bigint': return BigInt(val);
            case 'string': return String(val);
            case 'symbol': return Symbol(val);
            case 'undefined': return undefined;
            default: return val;
            }
        }
        function sortMap(map) {
            return new Map([...map.entries()].sort((a, b) => {
                if ((typeof a[0]) === (typeof b[0])) {
                    switch (typeof a[0]) {
                    case 'string': return a[0].localeCompare(b[0]);
                    case 'number':
                        if (Number.isNaN(a[0]) || Number.isNaN(b[0])) return Number.isNaN(a[0]) - Number.isNaN(b[0]);
                        return a[0] - b[0];
                    default: return 0;
                    }
                }
                return (typeof a[0]).localeCompare(typeof b[0]);
            }));
        }
    </script>
</body>
</html>